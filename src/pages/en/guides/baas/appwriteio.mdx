---
title: Appwrite & Astro
description: Add authentication, storage, and realtime data to your Astro application
layout: ~/layouts/BackendAsAServiceLayout.astro
service: Appwrite
stub: false
---
import FileTree from '~/components/FileTree.astro'
import PackageManagerTabs from '~/components/tabs/PackageManagerTabs.astro'



[Appwrite](https://appwrite.io/) is a self-hosted backend-as-a-service platform that provides developers with all the core APIs required to build any application.

## Integrating with Astro

In this section, we'll use the [Appwrite JavaScript SDK](https://appwrite.io/docs/getting-started-for-web#getSDK) to connect your Appwrite project to Astro.

### Prerequisites

To get started, you will need to have the following:

1. **An Astro project** - If you don't have an Astro project yet, our [Installation guide](/en/install/auto/) will get you up and running in no time.

2. **An Appwrite instance, or hosted instance**. If you don't have an account, you can [sign up](https://cloud.appwrite.io/login) for a free account and create a new Appwrite project. You can also use an existing project if you have one. 

3. **Appwrite credentials** - You can find the following credentials in your Appwrite console **Project Overview > API key**. 

    - **Project ID** - The ID of your Project (not the name). 

### Setting up credentials

To add your Appwrite project's credentials to Astro, create an `.env` file in the root of your project with the following variables:

:::tip
You may find that you will need additional environment variables, feel free to continue adding to the `.env` file.
:::

```ini title=".env"
PUBLIC_PUBLIC_APPWRITE_ENDPOINT=YOUR_ENDPOINT
PUBLIC_PUBLIC_APPWRITE_PROJECT_ID=YOUR_PROJECT_ID
PUBLIC_PUBLIC_APPWRITE_DB_ID=YOUR_DATABASE_ID
PUBLIC_APPWRITE_BLOG_ID=YOUR_BLOG_COLLECTION_ID
PUBLIC_APPWRITE_COMMENTS_ID=YOUR_COMMENTS_COLLECTION_ID
PUBLIC_APPWRITE_BUCKET_ID=YOUR_STORAGE BUCKET_ID
...
```

Now, you should be able to use these environment variables in your project. 

If you would like to have IntelliSense for your Contentful environment variables, you can create a `env.d.ts` file in the `src/` directory and configure `ImportMetaEnv` like this:

```ts title="src/env.d.ts"
interface ImportMetaEnv {
  readonly PUBLIC_PUBLIC_APPWRITE_ENDPOINT: string;
  readonly PUBLIC_PUBLIC_APPWRITE_PROJECT_ID: string;
  readonly PUBLIC_PUBLIC_APPWRITE_DB_ID: string;
  readonly PUBLIC_APPWRITE_BLOG_ID: string;
  readonly PUBLIC_APPWRITE_COMMENTS_ID: string;
  readonly PUBLIC_APPWRITE_BUCKET_ID: string;
}
```
:::tip
Read more about [using environment variables](/en/guides/environment-variables/) and `.env` files in Astro.
:::

Your root directory should now include these new files:

<FileTree title="Project Structure">
- src/
  - **env.d.ts**
- **.env**
- astro.config.mjs
- package.json
</FileTree>

### Installing dependencies

To connect with your Appwrite project, install both of the following using the single command below for your preferred package manager:
- [`appwrite`](https://github.com/appwrite/sdk-for-web), the official Appwrite SDK for JavaScript.

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npm install appwrite
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm install appwrite
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn add appwrite
  ```
  </Fragment>
</PackageManagerTabs>

Next, create a new file called `appwrite.ts` in `src/lib/` directory in your project.

```ts title="src/lib/appwrite.ts"
import { Client, Databases } from 'appwrite';

export interface BlogPost {
    title: string;
    date: string;
    description: string;
    content: Document;
    slug: string;
}

export const appwriteClient = new Client()
    .setEndpoint(import.meta.env.PUBLIC_APPWRITE_ENDPOINT) // Your API Endpoint
    .setProject(import.meta.env.PUBLIC_APPWRITE_PROJECT_ID); // Your project ID
```

The above code snippet creates a new Appwrite client, passing in credentials from the `.env` file. 

Finally, your root directory should now include these new files:

<FileTree title="Project Structure">
- src/
  - env.d.ts
  - lib/
    - **appwrite.ts**
- .env
- astro.config.mjs
- package.json
</FileTree>

### Fetching data

Include databases in your appwrite.ts file so that you can use this wherever you might need data.

```ts
export const appwriteDatabases = new Databases(appwriteClient);
```

Now, Astro components can fetch your data using the `appwriteDatabases`.

For example, if you want to build blog pages.

```astro
---
import { appwriteDatabases } from "../lib/appwrite";

interface BlogPost {
    title: string,
    content: string
}

const entries = await databases.createDocument('[DATABASE_ID]', '[COLLECTION_ID]', '[DOCUMENT_ID]', {});
---

<body>
  {entries.items.map((item) => (
    <section>
      <h2>{item.fields.name}</h2>
      <article set:html={html}></article>
    </section>
  ))}
</body>
```

## Making a blog with Astro and Appwrite

With the setup above, you are now able to create a blog that uses Appwrite as your backend.

You can find the full example on https://github.com/appwrite/demos-for-astro.

### Prerequisites

Install Appwrite's CLI, if you want to use and additional method see [Appwrite CLI](https://appwrite.io/docs/command-line)

<PackageManagerTabs>
  <Fragment slot="npm">
  ```shell
  npm install -g appwrite-cli
  ```
  </Fragment>
  <Fragment slot="pnpm">
  ```shell
  pnpm install -g appwrite-cli
  ```
  </Fragment>
  <Fragment slot="yarn">
  ```shell
  yarn add -g appwrite-cli
  ```
  </Fragment>
</PackageManagerTabs>

Once you have the CLI installed make sure to login to you instance if local this will be `http://localhost/v1`.

  ```shell
  appwrite login
  ```

Add a new file called `appwrite.json` to the base of your project (or anywhere that you want to use the command) with the following content.
This will create a project with id `astro-example-blog`, database with id `astro-example-blog-db` and collection `astro-example-blog-posts`. To keep things simple the names also match the id.

```json
{
    "projectId": "6062f9c2c09ce",
    "projectName": "Appwrite Demos",
    "collections": [
        {
            "$id": "63ecf94aad01784f9c65",
            "$createdAt": "2023-02-15T15:24:58.708+00:00",
            "$updatedAt": "2023-02-19T22:17:01.591+00:00",
            "$permissions": [
                "read(\"any\")",
                "create(\"team:63f29f648b9a34a914d1\")",
                "read(\"team:63f29f648b9a34a914d1\")",
                "update(\"team:63f29f648b9a34a914d1\")",
                "delete(\"team:63f29f648b9a34a914d1\")"
            ],
            "databaseId": "default",
            "name": "Astro Example Blog",
            "enabled": true,
            "documentSecurity": false,
            "attributes": [
                {
                    "key": "date",
                    "type": "datetime",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "format": "",
                    "default": null
                },
                {
                    "key": "slug",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 255,
                    "default": null
                },
                {
                    "key": "title",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 255,
                    "default": null
                },
                {
                    "key": "content",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 1073741824,
                    "default": null
                },
                {
                    "key": "description",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 255,
                    "default": null
                },
                {
                    "key": "imageurl",
                    "type": "string",
                    "status": "available",
                    "required": false,
                    "array": false,
                    "format": "url",
                    "default": null
                }
            ],
            "indexes": [
                {
                    "key": "slug",
                    "type": "key",
                    "status": "available",
                    "attributes": [
                        "slug"
                    ],
                    "orders": [
                        "ASC"
                    ]
                }
            ]
        },
        {
            "$id": "63f6538dbe55918d0685",
            "$createdAt": "2023-02-22T17:40:29.779+00:00",
            "$updatedAt": "2023-02-22T18:46:38.358+00:00",
            "$permissions": [
                "create(\"users\")",
                "read(\"users\")"
            ],
            "databaseId": "default",
            "name": "Astro Example Comments",
            "enabled": true,
            "documentSecurity": true,
            "attributes": [
                {
                    "key": "postId",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 26,
                    "default": null
                },
                {
                    "key": "comment",
                    "type": "string",
                    "status": "available",
                    "required": true,
                    "array": false,
                    "size": 1073741824,
                    "default": null
                }
            ],
            "indexes": [
                {
                    "key": "postId",
                    "type": "key",
                    "status": "available",
                    "attributes": [
                        "postId"
                    ],
                    "orders": [
                        "ASC"
                    ]
                }
            ]
        }
    ]
}
```

Deploy the project based on the above `appwrite.json`.

  ```shell
  appwrite deploy project
  ```
Deploy the collection based on the above `appwrite.json`.

  ```shell
  appwrite deploy collection
  ```


### Displaying a list of blog posts

Create a new interface called `BlogPost` and add it to your `appwrite.ts` file in `src/lib/`. This interface will match the attributes of your blog post content type in Appwrite. You will use it to type your blog post entries response.

```ts title="src/lib/appwrite.ts"
import { Client, Databases, Models } from 'appwrite';

export interface BlogPost extends Models.Document {
    title: string;
    date: string;
    description: string;
    content: string;
    slug: string;
}

export interface BlogPostList extends Models.DocumentList<BlogPost>{}

export const appwriteClient = new Client()
    .setEndpoint(import.meta.env.PUBLIC_APPWRITE_ENDPOINT) // Your API Endpoint
    .setProject(import.meta.env.PUBLIC_APPWRITE_PROJECT_ID); // Your project ID

export const appwriteDatabases = new Databases(appwriteClient);
```

Next, go to the Astro page `/src/pages/blog/index.astro` where you will fetch data from Appwrite's database.

```ts title="/src/pages/blog/index.astro"
---
import BaseHead from "../../components/BaseHead.astro";
import Header from "../../components/Header.astro";
import Footer from "../../components/Footer.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../../consts";
import { appwriteDatabases, BlogPostList } from "../../lib/appwrite";

const entries = (await appwriteDatabases.listDocuments(
  import.meta.env.PUBLIC_APPWRITE_DB_ID,
  import.meta.env.PUBLIC_APPWRITE_BLOG_ID
)) as BlogPostList;

const posts = entries.documents.sort(
  (a, b) => new Date(a.date).valueOf() - new Date(b.date).valueOf()
);
---

<!DOCTYPE html>
<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
    <style>
      ul {
        list-style-type: none;
        padding: unset;
      }
      ul li {
        display: flex;
      }
      ul li time {
        flex: 0 0 130px;
        font-style: italic;
        color: #595959;
      }
      ul li a:visited {
        color: #8e32dc;
      }
    </style>
  </head>
  <body>
    <Header />
    <main>
      <section>
        <ul>
          {
            posts.map((post) => (
              <li>
                <time datetime={post.date}>
                  {new Date(post.date).toLocaleDateString("en-us", {
                    year: "numeric",
                    month: "short",
                    day: "numeric",
                  })}
                </time>
                <a href={`/blog/${post.slug}/`}>{post.title}</a>
              </li>
            ))
          }
        </ul>
      </section>
    </main>
    <Footer />
  </body>
</html>

```

### Generating individual blog posts

If you're using Astro's default static mode, you'll use dynamic routes and the `getStaticPaths()` function. This function will be called at build time to generate the list of paths that become pages.

Create a new file named `[slug].astro` in `src/pages/blog/`.

As you did on `index.astro`, import the `BlogPost` interface and `appwriteDatabases` from `src/lib/appwrite.ts`.

This time, fetch your data inside a `getStaticPaths()` function.

```ts title="example-blog/src/pages/blog/[...slug].astro"
---
import BlogPost from "../../layouts/BlogPost.astro";
import {
  appwriteDatabases,
  BlogPost as BlogPostType,
  BlogPostList,
} from "../../lib/appwrite";

export async function getStaticPaths() {
  const entries = (await appwriteDatabases.listDocuments(
    import.meta.env.PUBLIC_APPWRITE_DB_ID,
    import.meta.env.PUBLIC_APPWRITE_BLOG_ID
  )) as BlogPostList;

  const posts = entries.documents.sort(
    (a, b) => new Date(a.date).valueOf() - new Date(b.date).valueOf()
  );
  return posts.map((post) => ({
    params: { slug: post.slug },
    props: post,
  }));
}
type Props = BlogPostType;

const post = Astro.props;
---

<BlogPost {...post.data}>
  <h1>{post.title}</h1>
  {post.content}
</BlogPost>
```

The property inside params must match the name of the dynamic route. Since our filename is `[slug].astro`, we use slug.

In our example, the props object passes three properties to the page:

title (a string)
content (a string)
date (a string in DateTime format)
Finally, you can use the page props to display your blog post.


### Adding Realtime

#### Setup

In order to show off our realtime capabilities we will create a new `src/components/Comments.astro` file. This component takes in `postId` as a prop and binds that to a new custom element called `appwrite-post-comments`.

> Please note that dataset attributes must be lowercase.


Below you will find the basic scaffolding for the comment component.

```astro
---
interface Props {
  postId: string;
}
const { postId } = Astro.props;
---

<appwrite-post-comments data-postid={postId} style="display: none;">
  <div class="u-flex u-flex-vertical u-gap-16">
    <form class="form u-width-full-line u-flex u-flex-vertical u-gap-16">
      <ul class="form-list">
        <li class="form-item">
          <label class="label">Comments</label>
          <input name="comment" type="text" class="input-text" />
        </li>
      </ul>
      <button class="button u-cross-child-end" type="submit">Add Comment</button
      >
    </form>
    <ul class="list"></ul>
  </div>
</appwrite-post-comments>
```

In order for this to be placed on a page we must first define a classs.

```ts
  class AppwritePostComments extends HTMLElement {
    ...
  }
```

After we define the class we then use `customElements` define method.

```ts
customElements.define("appwrite-post-comments", AppwritePostComments);
```


#### Using Stores

Below we have added a few attributes to our class, a constructor which is called when the class is initialized, and a method called `showUsers` because we only show the comment block if the user is logged in.

In the below constructor we are getting the data provided to the html attribue `data-postid` by calling `this.dataset.postid`. We then update `postId` attribute on the `AppwritePostComments` class. After this is done we can determine if the comments section should be shown by calling `showUsers`. 

`user$` is a store that is updated async, you can read more about [nanostores](https://github.com/nanostores/nanostores) to see how this works.

```ts
class AppwritePostComments extends HTMLElement {

  databaseId = import.meta.env.PUBLIC_APPWRITE_DB_ID;
  collectionId = import.meta.env.PUBLIC_APPWRITE_COMMENTS_ID;
  postId: string = "";
  comments$: WritableAtom<BlogComment[]> = atom([]);

  constructor() {
    super();
    if (!this.dataset.postid) return;

    this.postId = this.dataset.postid;
    // Only show comments for users logged in.
    this.showUsers();
  }

  async showUsers() {
    user$.subscribe((user) => {
      if (user) {
        this.style.display = "block";
      } else {
        this.style.display = "none";
        return;
      }
      //Only users get comments
      this.addCommentInput();
      this.loadComments();
      this.subComments();
    });
  }
```

In the below method `addCommentInput` we use Appwrite's [createDocument](https://appwrite.io/docs/client/databases?sdk=web-default#databasesCreateDocument) API to add comments to another collection set by our environment variable `PUBLIC_APPWRITE_COMMENTS_ID`.

```ts
addCommentInput() {
  const formElem: HTMLFormElement | null = this.querySelector("form");
  const btnElem: HTMLButtonElement | null = this.querySelector("button");

  if (!formElem || !btnElem) return;

  formElem.addEventListener("submit", async (e) => {
    e.preventDefault();
    const commentInputElem: HTMLInputElement | null =
      formElem.querySelector('input[name="comment"]');
    if (commentInputElem) {
      const formData = new FormData(formElem);
      try {
        await appwriteDatabases.createDocument(
          this.databaseId,
          this.collectionId,
          ID.unique(),
          { ...Object.fromEntries(formData), postId: this.postId }
        );
        commentInputElem.value = "";
      } catch (error) {
        const appwriteError = error as AppwriteException;
        alert(appwriteError.message);
      }
    }
  });
}
```

In the below method `loadComments` we use Appwrite's [listDocuments](https://appwrite.io/docs/client/databases?sdk=web-default#databasesListDocuments) to initially set our `comments$` atom from our database. This attribute is set with an empty array as default on our Class `comments$: WritableAtom<BlogComment[]> = atom([]);`. This is only set when the element is initially added.

```ts
async loadComments() {
  try {
    const comments = await appwriteDatabases.listDocuments(
      this.databaseId,
      this.collectionId,
      [Query.equal("postId", this.postId), Query.orderDesc("$createdAt")]
    );
    this.comments$.set(comments.documents as BlogComment[]);
  } catch (error) {
    const appwriteError = error as AppwriteException;
    alert(appwriteError.message);
  }
}
```

In the below method `subComments` we first setup a listener for the atom. Whenever `comments$` is updated we can then update the HTML required to build out the list of comments. This listener could be placed anywhere, there is just no need to listen to updates if we don't subscribe.

In the second part of the method we then subscribe to a specific channel within Appwrite `databases.${this.databaseId}.collections.${this.collectionId}.documents` by calling the `subscribe` method. You can read more about all of the possible channels in our Appwrite [realtime docs](https://appwrite.io/docs/realtime).

When our comments are updated we then update the current array stored on `comments$` according to the update that was made whether it was `create`, `update`, or `delete`. Because our listener is already set when this update happens the HTML re-renders appropriatly.

```ts
async subComments() {
  this.comments$.listen((commentEvent) => {
    const commentsElem: HTMLUListElement | null =
      this.querySelector(".list");
    if (commentsElem) {
      commentsElem.replaceChildren();
      commentEvent.map((c) => {
        const commentItem = `<li class="list-item" data-postid="${c?.$id}">
      <span class="icon-chat" aria-hidden="true"></span>
      <span class="text">${c?.comment}</span>
    </li>`;
        commentsElem.insertAdjacentHTML("beforeend", commentItem);
      });
    }
  });

  const sub = `databases.${this.databaseId}.collections.${this.collectionId}.documents`;
  try {
    appwriteClient.subscribe(sub, (response) => {
      const updatedComment: BlogComment = response.payload as BlogComment;
      if (updatedComment.postId !== this.postId) {
        console.debug(
          `postId: ${updatedComment.postId} does not match current post ${this.postId}`
        );
        return;
      }

      if (response.events.includes(`${sub}.${updatedComment.$id}.create`)) {
        console.debug(`Adding: ${updatedComment.$id}`);
        // Append new payload to the list
        this.comments$.set([...[updatedComment], ...this.comments$.get()]);
      } else if (
        response.events.includes(`${sub}.${updatedComment.$id}.update`)
      ) {
        console.debug(`Updating: ${updatedComment.$id}`);
        // Find payload item and update
        const comments = this.comments$.get();
        this.comments$.set([
          ...comments.map((c) =>
            c.$id === updatedComment.$id ? updatedComment : c
          ),
        ]);
      } else if (
        response.events.includes(`${sub}.${updatedComment.$id}.delete`)
      ) {
        console.debug(`Removing: ${updatedComment.$id}`);
        // Find and remove payload item
        const comments = this.comments$.get();
        this.comments$.set([
          ...comments.filter((c) => c.$id !== updatedComment.$id),
        ]);
      }
    });
  } catch (error) {
    const appwriteError = error as AppwriteException;
    alert(appwriteError.message);
  }
}
```

### Adding Storage

Utilizing Appwrite's [Storage](https://appwrite.io/docs/storage) we can include photo's on our blog as well. To do this we have a single component `src/components/UploadFile.astro`. The full custom element is complex but the two most important steps are as follows.


#### Input File

Listen to the file change event, this is when a user selects a file for upload.

```ts
this.fileInputElem?.addEventListener("change", async (e: any) => {
  console.log(e.currentTarget?.files);
  if (e?.currentTarget?.files?.length) {
    uploadHandler(e?.currentTarget?.files[0]);
  }
});
```

#### File Upload

Send this file to Appwrite using the storage API's method [createFile](https://appwrite.io/docs/client/storage?sdk=web-default#storageCreateFile).

```ts
const result = await appwriteStorage.createFile(
  import.meta.env.PUBLIC_APPWRITE_BUCKET_ID,
  ID.unique(),
  file
);
```

When the result is returned set the resulting file location like below.
```ts
this.elm.value = `${
  import.meta.env.PUBLIC_APPWRITE_ENDPOINT
}/storage/buckets/${
  import.meta.env.PUBLIC_APPWRITE_BUCKET_ID
}/files/${result.$id}/view?project=${
  import.meta.env.PUBLIC_APPWRITE_PROJECT_ID
}`;
```

#### Creating / Editing Blog Post

When you are on the create or edit blog screen you can update any fields including the image upload.
Once this happens you can simply pass `Object.fromEntries(formData)` as the data to update your blog post.

> Make sure that the input names match your database attributes.

```ts
form.addEventListener("submit", async (event) => {
  event.preventDefault();
  const formData = new FormData(form);
  try {
    await appwriteDatabases.updateDocument(
      import.meta.env.PUBLIC_APPWRITE_DB_ID,
      import.meta.env.PUBLIC_APPWRITE_BLOG_ID,
      id,
      Object.fromEntries(formData)
    );
    window.location.replace(`/blog/${post.slug}`);
  } catch (error) {
    const appwriteError = error as AppwriteException;
    alert(appwriteError.message);
  }
});
```
